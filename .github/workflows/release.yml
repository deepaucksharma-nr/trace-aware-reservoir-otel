name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v0.1.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        type: boolean
        default: false

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate version format
        run: |
          VERSION=${{ github.event.inputs.version }}
          if ! [[ $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\.]+)?$ ]]; then
            echo "::error::Invalid version format. Must be vX.Y.Z or vX.Y.Z-suffix"
            exit 1
          fi
          
          # Check if tag already exists
          if git tag | grep -q "^$VERSION$"; then
            echo "::error::Tag $VERSION already exists"
            exit 1
          fi
          
          echo "Version $VERSION is valid"

  build:
    name: Build and Tag Release
    needs: validate
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        run: |
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
          echo "GIT_COMMIT=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
      
      - name: Build & push production image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: build/docker/Dockerfile.streamlined
          target: production
          build-args: |
            VERSION=${{ steps.meta.outputs.VERSION }}
            BUILD_DATE=${{ steps.meta.outputs.BUILD_DATE }}
            GIT_COMMIT=${{ steps.meta.outputs.GIT_COMMIT }}
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/trace-reservoir:${{ steps.meta.outputs.VERSION }}
            ghcr.io/${{ github.repository_owner }}/trace-reservoir:latest
      
      - name: Build & push benchmark image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: build/docker/Dockerfile.streamlined
          target: benchmark
          build-args: |
            VERSION=${{ steps.meta.outputs.VERSION }}
            BUILD_DATE=${{ steps.meta.outputs.BUILD_DATE }}
            GIT_COMMIT=${{ steps.meta.outputs.GIT_COMMIT }}
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/trace-reservoir-bench:${{ steps.meta.outputs.VERSION }}
            ghcr.io/${{ github.repository_owner }}/trace-reservoir-bench:latest
      
      - name: Build binaries
        id: build_binaries
        run: |
          # Create release directory
          mkdir -p release-artifacts
          
          # Build for multiple platforms
          PLATFORMS="linux-amd64 linux-arm64 darwin-amd64 darwin-arm64"
          
          for platform in $PLATFORMS; do
            # Parse OS and architecture
            OS=$(echo $platform | cut -d'-' -f1)
            ARCH=$(echo $platform | cut -d'-' -f2)
            
            echo "Building for $OS/$ARCH..."
            
            # Set environment for cross-compilation
            export GOOS=$OS
            export GOARCH=$ARCH
            
            # Build collector
            go build -o release-artifacts/otelcol-reservoir-$OS-$ARCH ./apps/collector
            
            # Create archive
            if [ "$OS" = "windows" ]; then
              zip -j release-artifacts/otelcol-reservoir-${{ steps.meta.outputs.VERSION }}-$OS-$ARCH.zip release-artifacts/otelcol-reservoir-$OS-$ARCH
            else
              tar -czf release-artifacts/otelcol-reservoir-${{ steps.meta.outputs.VERSION }}-$OS-$ARCH.tar.gz -C release-artifacts otelcol-reservoir-$OS-$ARCH
            fi
          done
          
          # List the artifacts
          echo "Created the following artifacts:"
          ls -la release-artifacts/
      
      - name: Create Git tag
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a ${{ github.event.inputs.version }} -m "Release ${{ github.event.inputs.version }}"
          git push origin ${{ github.event.inputs.version }}
      
      - name: Generate release notes
        id: release_notes
        run: |
          # Find the latest tag before this release
          PREVIOUS_TAG=$(git tag --sort=-creatordate | grep -v "${{ github.event.inputs.version }}" | head -n 1)
          
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Generating changelog since $PREVIOUS_TAG..."
            # Extract commit messages since previous tag
            echo "## Changes since $PREVIOUS_TAG" > release-notes.md
            echo "" >> release-notes.md
            git log --pretty=format:"* %s" $PREVIOUS_TAG..HEAD >> release-notes.md
          else
            echo "First release, including all commits..."
            echo "## Initial Release" > release-notes.md
            echo "" >> release-notes.md
            git log --pretty=format:"* %s" >> release-notes.md
          fi
          
          # Add download links
          echo "" >> release-notes.md
          echo "## Docker Images" >> release-notes.md
          echo "" >> release-notes.md
          echo "* Production: \`ghcr.io/${{ github.repository_owner }}/trace-reservoir:${{ steps.meta.outputs.VERSION }}\`" >> release-notes.md
          echo "* Benchmark: \`ghcr.io/${{ github.repository_owner }}/trace-reservoir-bench:${{ steps.meta.outputs.VERSION }}\`" >> release-notes.md
          
          cat release-notes.md
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.inputs.version }}
          name: Release ${{ github.event.inputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
          files: |
            release-artifacts/*.tar.gz
            release-artifacts/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  verify:
    name: Verify Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}
      
      - name: Pull and verify Docker image
        run: |
          # Pull the image
          docker pull ghcr.io/${{ github.repository_owner }}/trace-reservoir:${{ github.event.inputs.version }}
          
          # Verify the image
          echo "Verifying Docker image..."
          docker run --rm ghcr.io/${{ github.repository_owner }}/trace-reservoir:${{ github.event.inputs.version }} --version
      
      - name: Run basic checks
        run: |
          # Run the automated verification
          echo "Running basic functionality checks..."
          docker run -d --name test-collector \
            -p 8888:8888 \
            -e RESERVOIR_SIZE=1000 \
            -e WINDOW_DURATION=60s \
            -e TRACE_AWARE=true \
            ghcr.io/${{ github.repository_owner }}/trace-reservoir:${{ github.event.inputs.version }}
          
          # Wait for it to start
          sleep 5
          
          # Check if it's responding
          curl -s http://localhost:8888/metrics | grep -q "reservoir_sampler" && echo "✅ Metrics endpoint working" || echo "❌ Metrics endpoint failed"
          
          # Clean up
          docker stop test-collector
          docker rm test-collector